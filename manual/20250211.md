### ex) 가위바위보 구현하기

material_icon을 적용했다는 전제하에, chapter07_rps 하위에 script라는 폴더를 생성하니까 특이한 아이콘이 나왔다.
-> 이제는 자바스크립트가 유일한 스크립트 언어가 아니기 때문에 폴더명을 js나 javascript가 아닌 그냥 script를 사용한다.

#### 사용자와 컴퓨터의 패 입력받기
```javascript
let userInput = prompt("가위, 바위, 보 중 하나를 입력해주세요");
```

컴퓨터는 가위, 바위, 보를 어떻게 구분할 것인가?
-> `Math.random()`을 사용한다.

실행할 때마다 매번 다른 값을 return해 주는 함수이다.
-> 0 이상 1 미만의 number 값을 return해준다.

#### garbage in, garbage out
'쓰레기 값을 입력하면 쓰레기 값이 나온다'라는 뜻의 격언.
-> 유효성 검사를 필수적으로 수행하여 정상인 경우에만 그 다음 로직을 수행할 수 있어야 한다.

#### 상수란?
원래 개념은 절대 바뀌지 않는 값을 의미한다. 원래 JS에서는 상수(constant)가 존재하지 않았고, 변수(variable)만 있었다. 표준 여섯번째 버전 (ES6 버전) 이후 const 키워드가 생기면서 상수 개념이 생겼다.

일반적으로 변수는 camel case 표기 (예시: `let userName = 'Jhon Duran';`)를 따르지만, 상수의 경우 대문자로 이루어진 snake case(`const MAX_SIZE = 128;`)를 사용한다.

다만 const를 선언하지 않고 var / let으로 대문자 표기를 하더라도, 브라우저는 상수가 아닌 변수로 취급한다.

하지만, 개발자들끼리의 약속으로 만들어진 이름이 대문자로 선언된 경우에는 암묵적으로 그 값을 바꾸지 않는다.

이 개념을 바탕으로 script.js에 있는 `'가위','바위','보'`라는 string 값들을 전부 상수로 바꿀 예정이다.

다만 이를 `'SCISSORS','ROCK','PAPER'`로 교체하면 한국인 개발자 입장에서는 더 번거로워질 수 있다. 그럼에도 자주 사용되는 문자를 상수로 교체하는 이유는 다음과 같은 이유가 존재할 수 있다.

* 문자열을 다른 문자열로 교체하고 싶을 때, 예를 들어 가위, 바위, 보를 각각 묵, 찌, 빠로 고치고 싶다면 상수선언을 한 경우, 한 부분만 고치면 그만이지만 그대로 남겨뒀을 경우 하나하나 검색해서 수정해야 한다.

즉, 유지보수상의 이점 때문에 문자열 데이터를 그대로 사용하지 않고 상수로 교체하는 것이다.

#### switch문으로 바꿔보기
일반적으로는 if문이 더 많이 쓰이지만, 하나의 변수를 여러 값과 비교하는 경우 switch문으로 교체할 수 있다. 전체적인 가독성을 고려햐여 선택하는 것이 좋다.

기억할 만한 switch 관련 요소:
- break
- 순서대로 실행된다는 점
- default : 케이스에 해당하지 않은 경우에 실행되는 부분.

### ex) GUI 기반으로 가위, 바위, 보 만들기
#### `<button>` 태그로 사용자 입력 받기
: -> index.html의 body 태그에 button 태그 추가
#### 클릭 이벤트 알아보기
: 브라우저 내에서 어떤 버튼(button 태그 등)을 클릭하면 '클릭 이벤트'가 발생한다. 그러면 브라우저는 클릭 이벤트 핸들러를 찾아서 실행시키게 된다.

만약 연결된 이벤트 핸들러가 없다면 내부적으로는 클릭 이벤트가 발생했더라도 브라우저는 액션이 없다.

클릭 이벤트와 이벤트 핸들러의 개념을 알아두는 것이 중요하다.

index.html 문서에서
```html
<button onclick="alert('버튼이 클릭되었습니다.')">가위</button>
```
중 onclick="alert('버튼이 클릭되었습니다.')" 부분은 **onclick 이벤트 핸들러 설정**에 해당한다.
-> 버튼을 누르는 행위 : 'click 이벤트 발생'
-> 알림창이 팝업 형태로 뜨는 것 : 'onclick 이벤트 핸들러 실행'에 해당.

##### 클릭 이벤트 핸들러 적용하기
사용자가 '가위' 버튼을 누르면 프롬프트 창에서 '가위'라고 입력한 것과 동일한 효과를 가져와야 한다. 각 버튼을 선택했을 때 실행되는 코드를 각 버튼의 onclick 속성으로 작성하고, 버튼을 클릭할 때마다 각각의 이벤트 핸들러가 실행되도록 작성할 수 있다.

이벤트 핸들러를 onclick에 모두 작성했을 때 너무 비효율적이라는 것을 확인할 수 있다.

##### 함수를 사용해 이벤트 핸들러 적용하기
onclick에 대입하기 편하려고 함수를 정의하고 호출한다는 점은 이해할 수 있다.

함수를 이용한 로직의 추상화 :
선언되어 있는 함수를 사용/호출하고자할 때 필요한 것은 함수명, argument, return 값이다. 해당 정보들은 함수과 외부되는 접점을 나타내므로 인터페이스(`interface`)라고 한다.

프로그램을 개발할 때 함수 내에서 실제로 실행되는 로직의 방식은 크게 중요하지 않다. 예를 들어 숫자 두 개를 argument로 제공했을 때 우리가 필요한 결과값은 덧셈/뺄셈/나눗셈/곱셈/제곱 등등이 필요할 뿐이지 함수 내부에 정의되어있는 방식은 우리에게 중요하지 않다. 다만, 평균을 구할 때 (a+b)/2로 구현한 것을, 세 수의 평균을 구할 때 일일이 바꾼 뒤 코드가 제대로 작동하는지 테스트 해야한다면, 함수를 정의하고 함수를 호출하는 방식으로 코드를 작성했을 때는, 함수 정의된 부분만 고치면 된다는 이점을 얻을 수 있다.

함수의 세부 구현 방식을 추상화시켜 프로그램 내 다른 부분과의 영향도를 최소로 줄일 수 있다는 점이 함수의 장점에 해당한다.

```javascript
function average(num1, num2){
  return (Number(num1)+Number(num2))/2;
}

console.log(average(1)); //NaN 리턴.
console.log(average(1,2,3)); //앞에 두개만 처리해서 1.5 리턴.
```
우리에게 익숙했던 자바를 생각해보면, 두번째의 경우, 자바에서는 바로 에러를 내보내지만, 자바스크립트에서는 맨 앞부터 받을 수 있는 인수까지만 처리해서 함숫값을 return한다.

이에 대해 설명을 해보자면,

argument들은 왼쪽에서부터 차례차례 함수의 매개변수에 대입된다. 하지만, 할당된 값이 없는 num2의 경우 `undefined`로 남아있게 되고, `num1 + num2 = 1 + undefined`가 되기 떄문에 그 연산 결과 NaN(Not-a-Number의 축약어)가 된다. 후속 연산 결과도 NaN을 리턴한다.

하지만 순서대로 argument가 매개변수에 대입되기 때문에 (1,2,3)의 경우 3은 신경쓰지 않고 2까지만 대입이 되고 연산은 정상적으로 이루어지는 것처럼 보인다.

#### 첫 코드 개선하기
현재까지 한 것들은 **if문으로 작성해보기 -> switch문으로 개선하기 -> prompt() 대신 GUI를 사용해 입력받기** 까지 했다.

현재 script2.js 코드의 문제점은 가위, 바위, 보에 대한 함수가 따로 있고 새 함수를 만들 때마다 중복되는 로직과 코드가 많고 수정되는 부분은 매우 적어 유지보수하는데 어려움이 있다는 것이다.

따라서 어떠한 버튼을 누르더라도 하나의 함수가 실행되도록 `onButtonClick()` 함수를 만들어보자.

#### 리팩토링 (Refactoring)
외부적인 동작을 바꾸지 않으면서 내부의 구현을 개선하는 작업.

리팩토링에서의 중요한 점
 * '외부의 동작을 바꾸지 않으면서'라는 부분이 제일 중요하다.

##### 결과 출력 부분 개선
현재까지는 `alert()` 부분이 승,무,패 형태로 반복된다는 점을 확인할 수 있다. `result` 라는 string을 만들어서 조건문에 들어갈 때마다 result에 새로운 내용을 추가하고, 나중에 `result`를 통으로 출력하는 방식으로 수정할 수 있다. 변수 하나인 풀이법 / 변수 두개인 풀이법 형태가 존재한다.

이 외에도 다양한 리팩토링 방식이 존재할 수 있다.

'가위, 바위, 보' 예제는 여기서 끝.